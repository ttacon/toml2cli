package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"golang.org/x/tools/imports"
)

var (
	// Options for running goimports later on.
	options = &imports.Options{
		TabWidth:  8,
		TabIndent: true,
		Comments:  true,
		Fragment:  true,
	}
)

// urfaveGenerator is the generator for urfave/cli CLIs.
func urfaveGenerator(outFile string, m *MetaInfo) error {
	buf := bytes.NewBuffer(nil)

	// Generator general info first.
	buf.WriteString("app := cli.NewApp()\n")
	if name, ok := m.General["name"]; ok {
		buf.WriteString(fmt.Sprintf("app.Name = %q\n", name))
	}
	if desc, ok := m.General["description"]; ok {
		buf.WriteString(fmt.Sprintf("app.Usage = %q\n", desc))
	}

	if err := urfaveAddCommands(buf, m); err != nil {
		return err
	}

	buf.WriteString("if err := app.Run(os.Args); err != nil { log.Fatal(err) }")

	fileBuf := bytes.NewBufferString(fmt.Sprintf(`
package main

// DO NOT MODIFY: generated by github.com/ttacon/toml2cli
// If you need to make changes, update the toml config and then regenerate
// this file.

func main() {
%s
}
`, buf.String()))

	processed, err := imports.Process("", fileBuf.Bytes(), options)
	if err != nil {
		return err
	}

	if len(outFile) == 0 {
		// Purge to stdout
		fmt.Println(string(processed))
		return nil
	}

	return ioutil.WriteFile(outFile, processed, os.ModePerm)
}

type StrOutput struct {
	field  string
	quoted bool
}

// urfaveComandStrFields is a mapping of command fields to string values and if
// they need to be quoted or not in the config.
var urfaveCommandStrFields = map[string]StrOutput{
	"name":         {"Name", true},
	"category":     {"Category", true},
	"usage":        {"Usage", true},
	"usageText":    {"UsageText", true},
	"description":  {"Description", true},
	"argsUsage":    {"ArgsUsage", true},
	"helpName":     {"HelpName", true},
	"before":       {"Before", false},
	"after":        {"After", false},
	"action":       {"Action", false},
	"bashComplete": {"BashComplete", false},
	"onUsageError": {"OnUsageError", false},
}

// urfaveAddCommands generates the CLI commands for `urfave/cli` and writes them
// to the given buffer.
func urfaveAddCommands(buf *bytes.Buffer, m *MetaInfo) error {
	// Add preamble
	_, err := buf.WriteString("\napp.Commands = []cli.Command{\n")
	if err != nil {
		return err
	}

	// Time to generate some commands!
	for _, command := range m.Commands {
		if _, err = buf.WriteString("cli.Command{\n"); err != nil {
			return err
		}

		for key, field := range urfaveCommandStrFields {
			if value, ok := strFromMap(key, command); ok {
				formatString := "%s: %s,\n"
				if field.quoted {
					formatString = "%s: %q,\n"
				}
				if _, err := buf.WriteString(
					fmt.Sprintf(formatString, field.field, value),
				); err != nil {
					return err
				}
			}
		}

		if aliases, ok := strSliceFromMap("aliases", command); ok {
			if _, err := buf.WriteString(
				fmt.Sprintf(
					"Aliases: []string{ %q },\n",
					strings.Join(aliases, "\", \""),
				),
			); err != nil {
				return err
			}
		}

		if _, err = buf.WriteString("},\n"); err != nil {
			return err
		}
	}

	_, err = buf.WriteString("}\n")
	return err
}

// strFromMap extracts a string value from the map, if it can.
func strFromMap(key string, m map[string]interface{}) (string, bool) {
	raw, ok := m[key]
	if !ok {
		return "", ok
	}

	str, ok := raw.(string)
	return str, ok

}

// strSliceFromMap extracts a `[]string` value from the map, if it can.
func strSliceFromMap(key string, command map[string]interface{}) ([]string, bool) {
	raw, ok := command[key]
	if !ok {
		return nil, ok
	}

	rawSlice, ok := raw.([]interface{})
	if !ok {
		return nil, ok
	}

	var vals = make([]string, len(rawSlice))
	for i, val := range rawSlice {
		// dirty hack but less typing :D
		if vals[i], ok = val.(string); !ok {
			return nil, ok
		}
	}

	return vals, true
}
