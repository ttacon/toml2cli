package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"

	"golang.org/x/tools/imports"
)

var (
	// Options for running goimports later on.
	options = &imports.Options{
		TabWidth:  8,
		TabIndent: true,
		Comments:  true,
		Fragment:  true,
	}
)

// urfaveGenerator is the generator for urfave/cli CLIs.
func urfaveGenerator(outFile string, m *MetaInfo) error {
	buf := bytes.NewBuffer(nil)

	// Generator general info first.
	buf.WriteString("app := cli.NewApp()\n")
	if name, ok := m.General["name"]; ok {
		buf.WriteString(fmt.Sprintf("app.Name = %q\n", name))
	}
	if desc, ok := m.General["description"]; ok {
		buf.WriteString(fmt.Sprintf("app.Usage = %q\n", desc))
	}

	if err := urfaveAddCommands(buf, m); err != nil {
		return err
	}

	buf.WriteString("if err := app.Run(os.Args); err != nil { log.Fatal(err) }")

	fileBuf := bytes.NewBufferString(fmt.Sprintf(`
package main

// DO NOT MODIFY: generated by github.com/ttacon/toml2cli
// If you need to make changes, update the toml config and then regenerate
// this file.

import cli "github.com/urfave/cli/v2"

func main() {
%s
}
`, buf.String()))

	processed, err := imports.Process("", fileBuf.Bytes(), options)
	if err != nil {
		return err
	}

	if len(outFile) == 0 {
		// Purge to stdout
		fmt.Println(string(processed))
		return nil
	}

	return ioutil.WriteFile(outFile, processed, os.ModePerm)
}

type StrOutput struct {
	field  string
	quoted bool
}

// urfaveComandStrFields is a mapping of command fields to string values and if
// they need to be quoted or not in the config.
var urfaveCommandStrFields = map[string]StrOutput{
	"name":         {"Name", true},
	"category":     {"Category", true},
	"usage":        {"Usage", true},
	"usageText":    {"UsageText", true},
	"description":  {"Description", true},
	"argsUsage":    {"ArgsUsage", true},
	"helpName":     {"HelpName", true},
	"before":       {"Before", false},
	"after":        {"After", false},
	"action":       {"Action", false},
	"bashComplete": {"BashComplete", false},
	"onUsageError": {"OnUsageError", false},
}

// urfaveAddCommands generates the CLI commands for `urfave/cli` and writes them
// to the given buffer.
func urfaveAddCommands(buf *bytes.Buffer, m *MetaInfo) error {
	// Add preamble
	_, err := buf.WriteString("\napp.Commands = []*cli.Command{\n")
	if err != nil {
		return err
	}

	// Time to generate some commands!
	for _, command := range m.Commands {
		if _, err = buf.WriteString("&cli.Command{\n"); err != nil {
			return err
		}

		for key, field := range urfaveCommandStrFields {
			if value, ok := strFromMap(key, command); ok {
				formatString := "%s: %s,\n"
				if field.quoted {
					formatString = "%s: %q,\n"
				}
				if _, err := buf.WriteString(
					fmt.Sprintf(formatString, field.field, value),
				); err != nil {
					return err
				}
			}
		}

		if aliases, ok := strSliceFromMap("aliases", command); ok {
			if _, err := buf.WriteString("Aliases: []string{\n"); err != nil {
				return err
			}

			for _, alias := range aliases {
				if _, err := buf.WriteString(
					fmt.Sprintf("%q,\n", alias),
				); err != nil {
					return err
				}
			}
			if _, err := buf.WriteString("},\n"); err != nil {
				return err
			}
		}

		if flags, ok := mapSliceFromMap("flags", command); ok {
			if _, err := buf.WriteString(urfaveAddFlags(flags)); err != nil {
				return err
			}
		}

		if _, err = buf.WriteString("},\n"); err != nil {
			return err
		}
	}

	_, err = buf.WriteString("}\n")
	return err
}

func urfaveAddFlags(flags []map[string]interface{}) string {
	if len(flags) == 0 {
		return ""
	}

	buf := bytes.NewBuffer(nil)
	buf.WriteString("Flags: []cli.Flag{\n")
	for _, flg := range flags {
		typ, ok := strFromMap("type", flg)
		if !ok {
			continue
		}

		var (
			typeType  string
			valWriter func(interface{}) string
		)
		switch typ {
		case "string":
			typeType = "StringFlag"
			valWriter = stringWriter
		case "bool":
			typeType = "BoolFlag"
			valWriter = boolWriter
		case "int":
			typeType = "IntFlag"
			valWriter = intWriter
		case "int64":
			typeType = "Int64Flag"
			valWriter = intWriter
		case "int32":
			typeType = "Int32Flag"
			valWriter = intWriter
		case "timestamp":
			typeType = "TimestampFlag"
			valWriter = stringWriter
		default:
			continue // not currently supported
		}

		buf.WriteString(fmt.Sprintf("&cli.%s{\n", typeType))

		if name, ok := strFromMap("name", flg); ok {
			buf.WriteString(fmt.Sprintf("Name: %q,\n", name))
		}

		if usage, ok := strFromMap("usage", flg); ok {
			buf.WriteString(fmt.Sprintf("Usage: %q,\n", usage))
		}

		if required, ok := boolFromMap("required", flg); ok {
			buf.WriteString(fmt.Sprintf("Required: %v,\n", required))
		}

		// BoolFlag's don't have default values so skip them.
		if value, ok := flg["value"]; ok && typ != "bool" {
			buf.WriteString(fmt.Sprintf("Value: %v,\n", valWriter(value)))
		} else if !ok && typ == "timestamp" {
			buf.WriteString(fmt.Sprint("Value: cli.NewTimestamp(time.Now()),\n"))
		}

		// Timestamp flags support optional layouts
		if typ == "timestamp" {
			layout, ok := flg["layout"]
			if !ok {
				layout = "2006-01-02T15:04:05"
			}
			buf.WriteString(fmt.Sprintf("Layout: %q,\n", layout))
		}

		if aliases, ok := strSliceFromMap("aliases", flg); ok {
			buf.WriteString("Aliases: []string{\n")
			for _, alias := range aliases {
				buf.WriteString(fmt.Sprintf("%q,\n", alias))
			}
			buf.WriteString("},\n")
		}
		buf.WriteString("},\n")
	}

	buf.WriteString("},\n")

	return buf.String()
}

func boolWriter(val interface{}) string {
	b, ok := val.(bool)
	if !ok {
		return "<invalid>"
	}

	return strconv.FormatBool(b)
}

func stringWriter(val interface{}) string {
	str, ok := val.(string)
	if !ok {
		return "<invalid>"
	}

	return fmt.Sprintf("%q", str)
}

func intWriter(val interface{}) string {
	v, ok := val.(int64) // ¯\_(ツ)_/¯
	if !ok {
		return "<invalid>"
	}

	return strconv.FormatInt(v, 10)
}

// strFromMap extracts a string value from the map, if it can.
func strFromMap(key string, m map[string]interface{}) (string, bool) {
	raw, ok := m[key]
	if !ok {
		return "", ok
	}

	str, ok := raw.(string)
	return str, ok
}

// boolFromMap extracts a bool value from the map, if it can.
func boolFromMap(key string, m map[string]interface{}) (bool, bool) {
	raw, ok := m[key]
	if !ok {
		return false, ok
	}

	bl, ok := raw.(bool)
	return bl, ok
}

// mapSliceFromMap extracts a slice of maps from the map, if it can.
func mapSliceFromMap(key string, m map[string]interface{}) ([]map[string]interface{}, bool) {
	raw, ok := m[key]
	if !ok {
		return nil, ok
	}

	val, ok := raw.([]map[string]interface{})
	return val, ok
}

// strSliceFromMap extracts a `[]string` value from the map, if it can.
func strSliceFromMap(key string, command map[string]interface{}) ([]string, bool) {
	raw, ok := command[key]
	if !ok {
		return nil, ok
	}

	rawSlice, ok := raw.([]interface{})
	if !ok {
		return nil, ok
	}

	var vals = make([]string, len(rawSlice))
	for i, val := range rawSlice {
		// dirty hack but less typing :D
		if vals[i], ok = val.(string); !ok {
			return nil, ok
		}
	}

	return vals, true
}
